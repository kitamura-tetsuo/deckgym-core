use std::{fs::File, io::Read};

use clap::Parser;

use deckgym::models::{Ability, Attack, Card, EnergyType};
use indexmap::IndexMap;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Flag to generate the database.rs instead. card_ids.rs is generated by default.
    #[arg(long)]
    database: bool,

    /// Flag to generate a map of attack effect texts to implementations.
    #[arg(long)]
    attack_map: bool,

    /// Flag to generate only missing attack effect map lines for effect_mechanic_map.rs.
    #[arg(long)]
    incremental_attack_map: bool,

    /// Flag to generate a map of ability effect texts to implementations.
    #[arg(long)]
    ability_map: bool,

    /// Flag to generate only missing ability effect map lines for effect_ability_mechanic_map.rs.
    #[arg(long)]
    incremental_ability_map: bool,
}

/// A CLI program to generate card_ids.rs and database.rs from the database.json file.
fn main() {
    let args = Args::parse();

    // Read the JSON file into Card structs
    let mut file = File::open("./database.json").expect("database.json should be there");
    let mut json_string = String::new();
    file.read_to_string(&mut json_string)
        .expect("Unable to read string");
    let deserialized_cards: Vec<Card> = serde_json::from_str(&json_string).unwrap();

    // Generate the Enum Names
    let mut card_map: IndexMap<String, Card> = IndexMap::new();
    let mut id_to_enum: IndexMap<String, String> = IndexMap::new();
    for card in deserialized_cards {
        // Remove special characters from the name
        let mut enum_name = (card.get_id() + &card.get_name())
            .replace(" ", "")
            .replace("-", "")
            .replace(".", "")
            .replace("'", "")
            .replace("♀", "F")
            .replace("♂", "M")
            .replace(":", "")
            .replace("é", "e");
        if enum_name.ends_with("ex") {
            enum_name = enum_name[..enum_name.len() - 2].to_string();
            enum_name.push_str("Ex");
        }
        card_map.insert(enum_name.clone(), card.clone());
        id_to_enum.insert(card.get_id().clone(), enum_name.clone());
    }

    if args.database {
        print_database(&card_map);
    } else if args.attack_map {
        print_attack_map(&card_map);
    } else if args.incremental_attack_map {
        print_incremental_attack_map(&card_map, "src/actions/effect_mechanic_map.rs");
    } else if args.ability_map {
        print_ability_map(&card_map);
    } else if args.incremental_ability_map {
        print_incremental_ability_map(&card_map, "src/actions/effect_ability_mechanic_map.rs");
    } else {
        print_enums(&card_map, &id_to_enum);
    }
}

fn print_enums(card_map: &IndexMap<String, Card>, id_to_enum: &IndexMap<String, String>) {
    println!("// This is code generated from the database.json by card_enum_generator.rs. Do not edit manually.");
    println!();
    println!("use serde::{{Deserialize, Serialize}};");
    println!("use strum_macros::EnumIter;");
    println!("use std::collections::HashMap;");
    println!("use std::sync::LazyLock;");
    println!();
    println!(
        "#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq, Serialize, Deserialize, EnumIter)]"
    );
    println!("pub enum CardId {{");
    for (name, _) in card_map.iter() {
        println!("    {name},");
    }
    println!("}}\n");
    println!();
    println!("static CARD_ID_MAP: LazyLock<HashMap<&'static str, CardId>> = LazyLock::new(|| {{");
    println!("    let mut map = HashMap::new();");
    for (id, enum_name) in id_to_enum.iter() {
        println!("    map.insert(\"{id}\", CardId::{enum_name});");
    }
    println!("    map");
    println!("}});");
    println!();
    println!("impl CardId {{");
    println!("    pub fn from_card_id(id: &str) -> Option<Self> {{");
    println!("        CARD_ID_MAP.get(id).copied()");
    println!("    }}");
    println!();
    println!("}}");
}

fn print_database(card_map: &IndexMap<String, Card>) {
    println!("// This is code generated from the database.json by card_enum_generator.rs. Do not edit manually.");
    println!();
    println!("use crate::{{");
    println!("    card_ids::CardId,");
    println!(
        "    models::{{Ability, Attack, Card, EnergyType, PokemonCard, TrainerCard, TrainerType}},"
    );
    println!("}};");
    println!();
    println!("pub fn get_card_by_enum(id: CardId) -> Card {{");
    println!("    match id {{");
    for (enum_name, card) in card_map.iter() {
        print_card(enum_name, card);
    }
    println!("    }}");
    println!("}}");
}

fn print_card(enum_name: &str, card: &Card) {
    match card {
        Card::Pokemon(pokemon_card) => {
            println!("        CardId::{enum_name} => Card::Pokemon(PokemonCard {{");
            println!("            id: \"{}\".to_string(),", pokemon_card.id);
            println!("            name: \"{}\".to_string(),", pokemon_card.name);
            println!("            stage: {},", pokemon_card.stage);
            println!(
                "            evolves_from: {},",
                to_rust_string(&pokemon_card.evolves_from)
            );
            println!("            hp: {},", pokemon_card.hp);
            println!(
                "            energy_type: EnergyType::{},",
                pokemon_card.energy_type
            );
            println!(
                "            ability: {},",
                to_rust_ability(&pokemon_card.ability)
            );
            print_attacks(&pokemon_card.attacks);
            println!(
                "            weakness: {},",
                to_rust_energy(pokemon_card.weakness)
            );
            println!(
                "            retreat_cost: {},",
                to_rust_energy_vec(&pokemon_card.retreat_cost)
            );
            println!(
                "            rarity: \"{}\".to_string(),",
                pokemon_card.rarity
            );
            println!(
                "            booster_pack: \"{}\".to_string(),",
                pokemon_card.booster_pack
            );
            println!("        }}),");
        }
        Card::Trainer(trainer_card) => {
            println!("        CardId::{enum_name} => Card::Trainer(TrainerCard {{");
            println!("            id: \"{}\".to_string(),", trainer_card.id);
            println!("            name: \"{}\".to_string(),", trainer_card.name);
            println!(
                "            effect: \"{}\".to_string(),",
                trainer_card.effect
            );
            println!(
                "            rarity: \"{}\".to_string(),",
                trainer_card.rarity
            );
            println!(
                "            booster_pack: \"{}\".to_string(),",
                trainer_card.booster_pack
            );
            println!(
                "            trainer_card_type: TrainerType::{:?},",
                trainer_card.trainer_card_type
            );
            println!("        }}),");
        }
    }
    // TODO: AttackIds and AbilitiesIds
}

fn print_attacks(attacks: &[Attack]) {
    println!("            attacks: vec![");
    for attack in attacks {
        println!("                Attack {{");
        println!(
            "                    energy_required: {},",
            to_rust_energy_vec(&attack.energy_required)
        );
        println!(
            "                    title: \"{}\".to_string(),",
            attack.title
        );
        println!("                    fixed_damage: {},", attack.fixed_damage);
        println!(
            "                    effect: {},",
            to_rust_string(&attack.effect)
        );
        println!("                }},");
    }
    println!("            ],");
}

fn to_rust_string(string: &Option<String>) -> String {
    match string {
        Some(string) => format!("Some(\"{string}\".to_string())"),
        None => "None".to_string(),
    }
}
fn to_rust_ability(ability: &Option<Ability>) -> String {
    match ability {
        Some(ability) => format!(
            "Some(Ability {{ title: \"{}\".to_string(), effect: \"{}\".to_string() }})",
            ability.title, ability.effect
        ),
        None => "None".to_string(),
    }
}
fn to_rust_energy(energy_type: Option<EnergyType>) -> String {
    match energy_type {
        Some(energy_type) => format!("Some(EnergyType::{energy_type})"),
        None => "None".to_string(),
    }
}
fn to_rust_energy_vec(energy_types: &Vec<EnergyType>) -> String {
    let mut result = "vec![".to_string();
    for energy_type in energy_types {
        result.push_str(&format!("EnergyType::{energy_type},"));
    }
    result.push(']');
    result
}

fn print_attack_map(card_map: &IndexMap<String, Card>) {
    // Collect all unique attack effect texts
    let mut effect_texts: IndexMap<String, ()> = IndexMap::new();

    for card in card_map.values() {
        if let Card::Pokemon(pokemon_card) = card {
            for attack in &pokemon_card.attacks {
                if let Some(effect) = &attack.effect {
                    effect_texts.insert(effect.clone(), ());
                }
            }
        }
    }

    println!(
        "// This code is initially generated from the database.json by card_enum_generator.rs."
    );
    println!("// but needs to be manually filled in with actual implementations.");
    println!();
    println!("use std::collections::HashMap;");
    println!("use std::sync::LazyLock;");
    println!();
    println!("use crate::{{actions::attacks::Mechanic, models::EnergyType}};");
    println!();
    println!("/// Map from attack effect text to its Mechanic.");
    println!("pub static EFFECT_MECHANIC_MAP: LazyLock<HashMap<&'static str, Mechanic>> = LazyLock::new(|| {{");
    println!("    let mut map: HashMap<&'static str, Mechanic> = HashMap::new();");

    // Sort effect texts alphabetically
    let mut sorted_effects: Vec<&String> = effect_texts.keys().collect();
    sorted_effects.sort();

    for effect_text in sorted_effects {
        // Escape the effect text for use in a string literal
        let escaped = effect_text
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n");
        println!("    // map.insert(\"{escaped}\", todo_implementation);");
    }

    println!("    map");
    println!("}});");
}

fn print_incremental_attack_map(card_map: &IndexMap<String, Card>, existing_path: &str) {
    let existing_contents = std::fs::read_to_string(existing_path)
        .expect("expected effect_mechanic_map.rs to be readable");
    let existing_effects = extract_existing_effect_texts(&existing_contents);

    // Collect all unique attack effect texts
    let mut effect_texts: IndexMap<String, ()> = IndexMap::new();
    for card in card_map.values() {
        if let Card::Pokemon(pokemon_card) = card {
            for attack in &pokemon_card.attacks {
                if let Some(effect) = &attack.effect {
                    effect_texts.insert(effect.clone(), ());
                }
            }
        }
    }

    let mut sorted_effects: Vec<&String> = effect_texts.keys().collect();
    sorted_effects.sort();

    for effect_text in sorted_effects {
        let escaped = effect_text
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n");
        if !existing_effects.contains(&escaped) {
            println!("    // map.insert(\"{escaped}\", todo_implementation);");
        }
    }
}

fn print_ability_map(card_map: &IndexMap<String, Card>) {
    // Collect all unique ability effect texts
    let mut effect_texts: IndexMap<String, ()> = IndexMap::new();

    for card in card_map.values() {
        if let Card::Pokemon(pokemon_card) = card {
            if let Some(ability) = &pokemon_card.ability {
                effect_texts.insert(ability.effect.clone(), ());
            }
        }
    }

    println!(
        "// This code is initially generated from the database.json by card_enum_generator.rs."
    );
    println!("// but needs to be manually filled in with actual implementations.");
    println!();
    println!("use std::collections::HashMap;");
    println!("use std::sync::LazyLock;");
    println!();
    println!("use crate::actions::abilities::AbilityMechanic;");
    println!();
    println!("/// Map from ability effect text to its AbilityMechanic.");
    println!("pub static EFFECT_ABILITY_MECHANIC_MAP: LazyLock<HashMap<&'static str, AbilityMechanic>> = LazyLock::new(|| {{");
    println!("    let mut map: HashMap<&'static str, AbilityMechanic> = HashMap::new();");

    // Sort effect texts alphabetically
    let mut sorted_effects: Vec<&String> = effect_texts.keys().collect();
    sorted_effects.sort();

    for effect_text in sorted_effects {
        let escaped = effect_text
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n");
        println!("    // map.insert(\"{escaped}\", todo_implementation);");
    }

    println!("    map");
    println!("}});");
    println!();
    println!(
        "pub fn ability_mechanic_from_effect(effect: &str) -> Option<&'static AbilityMechanic> {{"
    );
    println!("    EFFECT_ABILITY_MECHANIC_MAP.get(effect)");
    println!("}}");
}

fn print_incremental_ability_map(card_map: &IndexMap<String, Card>, existing_path: &str) {
    let existing_contents = std::fs::read_to_string(existing_path)
        .expect("expected effect_ability_mechanic_map.rs to be readable");
    let existing_effects = extract_existing_effect_texts(&existing_contents);

    // Collect all unique ability effect texts
    let mut effect_texts: IndexMap<String, ()> = IndexMap::new();
    for card in card_map.values() {
        if let Card::Pokemon(pokemon_card) = card {
            if let Some(ability) = &pokemon_card.ability {
                effect_texts.insert(ability.effect.clone(), ());
            }
        }
    }

    let mut sorted_effects: Vec<&String> = effect_texts.keys().collect();
    sorted_effects.sort();

    for effect_text in sorted_effects {
        let escaped = effect_text
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n");
        if !existing_effects.contains(&escaped) {
            println!("    // map.insert(\"{escaped}\", todo_implementation);");
        }
    }
}

fn extract_existing_effect_texts(contents: &str) -> std::collections::HashSet<String> {
    let mut results = std::collections::HashSet::new();
    let bytes = contents.as_bytes();
    let mut index = 0;
    while let Some(pos) = contents[index..].find("map.insert") {
        let start = index + pos;
        let quote = bytes[start..]
            .iter()
            .position(|&b| b == b'"')
            .map(|offset| start + offset);
        let quote = match quote {
            Some(q) => q,
            None => break,
        };
        let mut j = quote + 1;
        while j < bytes.len() {
            if bytes[j] == b'\\' {
                if j + 1 < bytes.len() {
                    j += 2;
                    continue;
                }
                break;
            }
            if bytes[j] == b'"' {
                break;
            }
            j += 1;
        }
        if j <= bytes.len() {
            let effect = contents[quote + 1..j].to_string();
            results.insert(effect);
        }
        index = j + 1;
    }
    results
}
